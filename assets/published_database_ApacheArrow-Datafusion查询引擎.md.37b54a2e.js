import{_ as e,o as a,c as s,Q as n}from"./chunks/framework.36bc40e2.js";const P=JSON.parse('{"title":"介绍","description":"","frontmatter":{},"headers":[],"relativePath":"published/database/ApacheArrow-Datafusion查询引擎.md","filePath":"published/database/ApacheArrow-Datafusion查询引擎.md","lastUpdated":1700106669000}'),l={name:"published/database/ApacheArrow-Datafusion查询引擎.md"},o=n(`<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><p><code>DataFusion</code> 是一个用 <code>Rust</code> 编写的可扩展查询引擎，使用 <code>Apache Arrow</code> 作为其内存格式，是一个查询引擎而非数据库，因此其本身不具备存储数据的能力</p><p>使用复杂的查询规划器、列式、多线程、矢量化执行引擎和分区数据源快速运行复杂的 <code>SQL</code> 和 <code>DataFrame</code> 查询</p><p><code>DataFusion</code> 旨在轻松定制，例如支持其他数据源、查询语言、函数、自定义运算符等</p><p>原生支持了查询<code>CSV，Parquet，Avro，Json</code>等存储格式，也支持了<code>本地，AWS S3，Azure Blob Storage，Google Cloud Storage</code>等多种数据源</p><h2 id="dbms-与-query-engine-的区别" tabindex="-1"><code>DBMS</code> 与 <code>Query Engine</code> 的区别 <a class="header-anchor" href="#dbms-与-query-engine-的区别" aria-label="Permalink to &quot;\`DBMS\` 与 \`Query Engine\` 的区别&quot;">​</a></h2><h4 id="dbms-database-management-system" tabindex="-1"><code>DBMS: DataBase Management System</code> <a class="header-anchor" href="#dbms-database-management-system" aria-label="Permalink to &quot;\`DBMS: DataBase Management System\`&quot;">​</a></h4><p><code>DBMS</code>是一个包含完整数据库管理特性的系统，主要包含以下几个模块：</p><ul><li>存储系统</li><li>元数据(<code>Catalog</code>)</li><li>查询引擎(<code>Query Engine</code>)</li><li>访问控制和权限</li><li>资源管理</li><li>管理工具</li><li>客户端</li><li>多节点管理</li></ul><h4 id="query-engine" tabindex="-1"><code>Query Engine</code> <a class="header-anchor" href="#query-engine" aria-label="Permalink to &quot;\`Query Engine\`&quot;">​</a></h4><p>查询引擎属于数据库管理系统的一部分，是用户与数据库交互的主要接口，主要作用是将面向用户的高阶查询语句翻译成可被具体执行的数据处理单元操作，然后执行操作获取数据</p><h2 id="datafusion查询引擎主要模块" tabindex="-1"><code>DataFusion</code>查询引擎主要模块 <a class="header-anchor" href="#datafusion查询引擎主要模块" aria-label="Permalink to &quot;\`DataFusion\`查询引擎主要模块&quot;">​</a></h2><ul><li><p>前端</p><p>主要涉及<code>DFParser</code>和<code>SqlToRel</code>这两个<code>struct</code></p><ul><li><p>语法解析</p></li><li><p>语义分析</p></li><li><p><code>Planner</code>：语法树转换成逻辑计划</p></li></ul></li><li><p>查询中间表示</p><p>主要涉及<code>LogicalPlan</code>和<code>Expr</code>这两个枚举类</p><ul><li><p><code>Expression</code>（表达式）/ <code>Type system</code>（类型系统）</p></li><li><p><code>Query Plan</code> / <code>Relational Operators</code>（关系算子）</p></li><li><p><code>Rewrites</code> / <code>Optimizations</code>（逻辑计划优化）</p></li></ul></li><li><p>查询底层表示</p><p>主要涉及<code>PhysicalPlanner</code>这个<code>trait</code>实现的逻辑计划到物理计划的转换，其中主要的关键点是<code>ExecutionPlan</code>和<code>PhysicalExpr</code></p><ul><li><p><code>Statistics</code>（物理计划算子的统计信息，辅助物理计划优化）</p></li><li><p><code>Partitions</code>（分块，多线程执行物理计划算子）</p></li><li><p><code>Sort orders</code>（物理计划算子对数据是否排序）</p></li><li><p><code>Algorithms</code>（物理计划算子的执行算法，如<code>Hash join</code>和<code>Merge join</code>）</p></li><li><p><code>Rewrites / Optimizations</code>（物理计划优化）</p></li></ul></li><li><p>执行运行时（算子）</p><p>主要涉及所有执行算子，如<code>GroupedHashAggregateStream</code></p><ul><li><p>分配资源</p></li><li><p>向量化计算</p></li></ul></li></ul><h2 id="自定义和扩展" tabindex="-1">自定义和扩展 <a class="header-anchor" href="#自定义和扩展" aria-label="Permalink to &quot;自定义和扩展&quot;">​</a></h2><p><code>DataFusion</code> 被设计为“分解”查询引擎</p><p>意味着开发人员可以混合和扩展其用例所需的 <code>DataFusion</code> 部分</p><p>例如， <code>ExecutionPlan</code> 运算或 <code>SqlToRel SQL</code> 规划器和优化器</p><p>为了实现这一点，<code>DataFusion</code> 在很多方面支持扩展</p><ul><li>从任何数据源读取（<code>TableProvider</code>）</li><li>自定义<code>catalogs, schemas, and table lists</code> (<code>CatalogProvider</code>)</li><li>使用 (<code>LogicalPlanBuilder</code>) 构建您自己的查询语言或计划</li><li>声明和使用用户定义的函数（<code>ScalarUDF</code> 和 <code>AggregateUDF</code>）</li><li>添加自定义优化器重写过程（<code>OptimizerRule</code> 和 <code>PhysicalOptimizerRule</code>）</li><li>扩展规划器以使用用户定义的逻辑和物理节点（<code>QueryPlanner</code>）</li></ul><h2 id="查询计划和执行" tabindex="-1">查询计划和执行 <a class="header-anchor" href="#查询计划和执行" aria-label="Permalink to &quot;查询计划和执行&quot;">​</a></h2><h4 id="sql方面" tabindex="-1"><code>sql</code>方面 <a class="header-anchor" href="#sql方面" aria-label="Permalink to &quot;\`sql\`方面&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">                Parsed with            SqlToRel creates</span></span>
<span class="line"><span style="color:#e1e4e8;">                sqlparser              initial plan</span></span>
<span class="line"><span style="color:#e1e4e8;">┌───────────────┐           ┌─────────┐             ┌─────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">│   SELECT *    │           │Query {  │             │Project      │</span></span>
<span class="line"><span style="color:#e1e4e8;">│   FROM ...    │──────────▶│..       │────────────▶│  TableScan  │</span></span>
<span class="line"><span style="color:#e1e4e8;">│               │           │}        │             │    ...      │</span></span>
<span class="line"><span style="color:#e1e4e8;">└───────────────┘           └─────────┘             └─────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">  SQL String                 sqlparser               LogicalPlan</span></span>
<span class="line"><span style="color:#e1e4e8;">                             AST nodes</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">                Parsed with            SqlToRel creates</span></span>
<span class="line"><span style="color:#24292e;">                sqlparser              initial plan</span></span>
<span class="line"><span style="color:#24292e;">┌───────────────┐           ┌─────────┐             ┌─────────────┐</span></span>
<span class="line"><span style="color:#24292e;">│   SELECT *    │           │Query {  │             │Project      │</span></span>
<span class="line"><span style="color:#24292e;">│   FROM ...    │──────────▶│..       │────────────▶│  TableScan  │</span></span>
<span class="line"><span style="color:#24292e;">│               │           │}        │             │    ...      │</span></span>
<span class="line"><span style="color:#24292e;">└───────────────┘           └─────────┘             └─────────────┘</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">  SQL String                 sqlparser               LogicalPlan</span></span>
<span class="line"><span style="color:#24292e;">                             AST nodes</span></span></code></pre></div><ol><li><code>sql</code>查询语句会使用<code>sqloarser</code>库(<code>https://github.com/sqlparser-rs/sqlparser-rs</code>)进行解析，变成<code>AST</code>（<code>Abstract Syntax Tree</code>抽象语法树）</li><li><code>AST</code>之后会通过<code>datafusion::sql::planner::SqlToRel</code>进行初始化，转变生成<code>LogicalPlan</code>（逻辑计划，由各个逻辑算子组成的树状结构）和<code>logical expressions Expr</code>(逻辑表达式)，用与计算生成期望的查询结果</li></ol><h4 id="dataframe方面" tabindex="-1"><code>DataFrame</code>方面 <a class="header-anchor" href="#dataframe方面" aria-label="Permalink to &quot;\`DataFrame\`方面&quot;">​</a></h4><p>使用 <code>DataFrame API</code> 执行计划时，该过程与 <code>SQL</code> 相同，只是 <code>DataFrame API</code> 直接使用 <code>LogicalPlanBuilder</code> 构建 <code>LogicalPlan</code>， 拥有自己的自定义查询语言的系统通常也会直接构建 <code>LogicalPlan</code></p><h4 id="计划执行planning" tabindex="-1">计划执行<code>Planning</code> <a class="header-anchor" href="#计划执行planning" aria-label="Permalink to &quot;计划执行\`Planning\`&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">            AnalyzerRules and      PhysicalPlanner          PhysicalOptimizerRules</span></span>
<span class="line"><span style="color:#e1e4e8;">            OptimizerRules         creates ExecutionPlan    improve performance</span></span>
<span class="line"><span style="color:#e1e4e8;">            rewrite plan</span></span>
<span class="line"><span style="color:#e1e4e8;">┌─────────────┐        ┌─────────────┐      ┌───────────────┐        ┌───────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">│Project      │        │Project(x, y)│      │ProjectExec    │        │ProjectExec    │</span></span>
<span class="line"><span style="color:#e1e4e8;">│  TableScan  │──...──▶│  TableScan  │─────▶│  ...          │──...──▶│  ...          │</span></span>
<span class="line"><span style="color:#e1e4e8;">│    ...      │        │    ...      │      │    ParquetExec│        │    ParquetExec│</span></span>
<span class="line"><span style="color:#e1e4e8;">└─────────────┘        └─────────────┘      └───────────────┘        └───────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;"> LogicalPlan            LogicalPlan         ExecutionPlan             ExecutionPlan</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">            AnalyzerRules and      PhysicalPlanner          PhysicalOptimizerRules</span></span>
<span class="line"><span style="color:#24292e;">            OptimizerRules         creates ExecutionPlan    improve performance</span></span>
<span class="line"><span style="color:#24292e;">            rewrite plan</span></span>
<span class="line"><span style="color:#24292e;">┌─────────────┐        ┌─────────────┐      ┌───────────────┐        ┌───────────────┐</span></span>
<span class="line"><span style="color:#24292e;">│Project      │        │Project(x, y)│      │ProjectExec    │        │ProjectExec    │</span></span>
<span class="line"><span style="color:#24292e;">│  TableScan  │──...──▶│  TableScan  │─────▶│  ...          │──...──▶│  ...          │</span></span>
<span class="line"><span style="color:#24292e;">│    ...      │        │    ...      │      │    ParquetExec│        │    ParquetExec│</span></span>
<span class="line"><span style="color:#24292e;">└─────────────┘        └─────────────┘      └───────────────┘        └───────────────┘</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;"> LogicalPlan            LogicalPlan         ExecutionPlan             ExecutionPlan</span></span></code></pre></div><p>为了尽可能高效地处理具有多行的大型数据集，需要花费大量精力进行规划和优化，具体方式如下：</p><ol><li>由<code>AnalyzerRules</code> 检查并重写 <code>LogicalPlan</code> 以强制实施检查语义规则，例如强类型检查</li><li><code>LogicalPlan</code>会被<code>OptimizerRules</code>重写进行优化，如<code>projection</code>投影、<code>filter pushdown</code>过滤器下推等，以提高效率</li><li><code>LogicalPlan</code> 由 <code>PhysicalPlanner</code> 转换为 <code>ExecutionPlan</code></li><li><code>ExecutionPlan</code>由<code>PhysicalOptimizerRules</code>重写，例如<code>sort</code>排序和<code>join selection</code>，以提高效率</li></ol><h4 id="data-sources数据源" tabindex="-1"><code>Data Sources</code>数据源 <a class="header-anchor" href="#data-sources数据源" aria-label="Permalink to &quot;\`Data Sources\`数据源&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Planning       │</span></span>
<span class="line"><span style="color:#e1e4e8;">requests       │            TableProvider::scan</span></span>
<span class="line"><span style="color:#e1e4e8;">information    │            creates an</span></span>
<span class="line"><span style="color:#e1e4e8;">such as schema │            ExecutionPlan</span></span>
<span class="line"><span style="color:#e1e4e8;">               │</span></span>
<span class="line"><span style="color:#e1e4e8;">               ▼</span></span>
<span class="line"><span style="color:#e1e4e8;">  ┌─────────────────────────┐         ┌──────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">  │                         │         │              │</span></span>
<span class="line"><span style="color:#e1e4e8;">  │impl TableProvider       │────────▶│ParquetExec   │</span></span>
<span class="line"><span style="color:#e1e4e8;">  │                         │         │              │</span></span>
<span class="line"><span style="color:#e1e4e8;">  └─────────────────────────┘         └──────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;">        TableProvider</span></span>
<span class="line"><span style="color:#e1e4e8;">        (built in or user provided)    ExecutionPlan</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Planning       │</span></span>
<span class="line"><span style="color:#24292e;">requests       │            TableProvider::scan</span></span>
<span class="line"><span style="color:#24292e;">information    │            creates an</span></span>
<span class="line"><span style="color:#24292e;">such as schema │            ExecutionPlan</span></span>
<span class="line"><span style="color:#24292e;">               │</span></span>
<span class="line"><span style="color:#24292e;">               ▼</span></span>
<span class="line"><span style="color:#24292e;">  ┌─────────────────────────┐         ┌──────────────┐</span></span>
<span class="line"><span style="color:#24292e;">  │                         │         │              │</span></span>
<span class="line"><span style="color:#24292e;">  │impl TableProvider       │────────▶│ParquetExec   │</span></span>
<span class="line"><span style="color:#24292e;">  │                         │         │              │</span></span>
<span class="line"><span style="color:#24292e;">  └─────────────────────────┘         └──────────────┘</span></span>
<span class="line"><span style="color:#24292e;">        TableProvider</span></span>
<span class="line"><span style="color:#24292e;">        (built in or user provided)    ExecutionPlan</span></span></code></pre></div><p><code>DataFusion</code> 包含多个用于常见用例的内置数据源，并且可以通过实现 <code>TableProvider</code> 特征进行扩展， <code>TableProvider</code> 提供用于规划的信息和用于执行的 <code>ExecutionPlans</code></p><ol><li><code>ListingTable</code>：从<code>Parquet, JSON, CSV, AVRO</code> 文件读取数据，支持具有 <code>HIVE</code> 样式分区、可选压缩、直接从远程对象存储读取等的单个文件或多个文件</li><li><code>MemTable</code>：从内存中的 <code>RecordBatches</code> 读取数据</li><li><code>StreamingTable</code>：从潜在的无限输入中读取数据</li></ol><h4 id="执行" tabindex="-1">执行 <a class="header-anchor" href="#执行" aria-label="Permalink to &quot;执行&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">           ExecutionPlan::execute             Calling next() on the</span></span>
<span class="line"><span style="color:#e1e4e8;">           produces a stream                  stream produces the data</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">┌───────────────┐      ┌─────────────────────────┐         ┌────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">│ProjectExec    │      │impl                     │    ┌───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#e1e4e8;">│  ...          │─────▶│SendableRecordBatchStream│────┤    └────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;">│    ParquetExec│      │                         │    │    ┌────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">└───────────────┘      └─────────────────────────┘    ├───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#e1e4e8;">              ▲                                       │    └────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;">ExecutionPlan │                                       │         ...</span></span>
<span class="line"><span style="color:#e1e4e8;">              │                                       │</span></span>
<span class="line"><span style="color:#e1e4e8;">              │                                       │    ┌────────────┐</span></span>
<span class="line"><span style="color:#e1e4e8;">            PhysicalOptimizerRules                    ├───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#e1e4e8;">            request information                       │    └────────────┘</span></span>
<span class="line"><span style="color:#e1e4e8;">            such as partitioning                      │    ┌ ─ ─ ─ ─ ─ ─</span></span>
<span class="line"><span style="color:#e1e4e8;">                                                      └───▶ None        │</span></span>
<span class="line"><span style="color:#e1e4e8;">                                                           └ ─ ─ ─ ─ ─ ─</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">           ExecutionPlan::execute             Calling next() on the</span></span>
<span class="line"><span style="color:#24292e;">           produces a stream                  stream produces the data</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">┌───────────────┐      ┌─────────────────────────┐         ┌────────────┐</span></span>
<span class="line"><span style="color:#24292e;">│ProjectExec    │      │impl                     │    ┌───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#24292e;">│  ...          │─────▶│SendableRecordBatchStream│────┤    └────────────┘</span></span>
<span class="line"><span style="color:#24292e;">│    ParquetExec│      │                         │    │    ┌────────────┐</span></span>
<span class="line"><span style="color:#24292e;">└───────────────┘      └─────────────────────────┘    ├───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#24292e;">              ▲                                       │    └────────────┘</span></span>
<span class="line"><span style="color:#24292e;">ExecutionPlan │                                       │         ...</span></span>
<span class="line"><span style="color:#24292e;">              │                                       │</span></span>
<span class="line"><span style="color:#24292e;">              │                                       │    ┌────────────┐</span></span>
<span class="line"><span style="color:#24292e;">            PhysicalOptimizerRules                    ├───▶│RecordBatch │</span></span>
<span class="line"><span style="color:#24292e;">            request information                       │    └────────────┘</span></span>
<span class="line"><span style="color:#24292e;">            such as partitioning                      │    ┌ ─ ─ ─ ─ ─ ─</span></span>
<span class="line"><span style="color:#24292e;">                                                      └───▶ None        │</span></span>
<span class="line"><span style="color:#24292e;">                                                           └ ─ ─ ─ ─ ─ ─</span></span></code></pre></div><p><code>ExecutionPlans</code> 使用 <code>Apache Arrow </code>内存格式处理数据，大量使用 <code>arrow crate</code> 中的函数。 调用<code>execute</code>会产生1个或多个数据分区，其中包含一个实现<code>SendableRecordBatchStream</code>的运算符。 值用 <code>ColumnarValue</code> 表示，可以是 <code>ScalarValue</code>（单个常量值）或 <code>ArrayRef</code>（箭头数组）。 平衡并行性是使用 <code>RepartitionExec</code> 实现的，它实现了 <code>Volcano</code> 风格的“交换”</p><h2 id="参考阅读" tabindex="-1">参考阅读 <a class="header-anchor" href="#参考阅读" aria-label="Permalink to &quot;参考阅读&quot;">​</a></h2><p><a href="https://docs.rs/datafusion/latest/datafusion/index.html#architecture" target="_blank" rel="noreferrer"><code>Datafusion Docs.rs Architecture</code></a></p><p><a href="https://www.cnblogs.com/leometeor/p/17397333.html" target="_blank" rel="noreferrer"><code>Apache Arrow DataFusion</code>原理与架构</a></p>`,39),c=[o];function p(i,t,r,d,u,h){return a(),s("div",null,c)}const m=e(l,[["render",p]]);export{P as __pageData,m as default};
