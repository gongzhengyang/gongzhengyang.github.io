import{_ as e,o as a,c as o,Q as l}from"./chunks/framework.36bc40e2.js";const y=JSON.parse('{"title":"共识的含义","description":"","frontmatter":{},"headers":[],"relativePath":"published/算法/区块链常见共识算法概述.md","filePath":"published/算法/区块链常见共识算法概述.md","lastUpdated":1700106669000}'),c={name:"published/算法/区块链常见共识算法概述.md"},s=l('<h1 id="共识的含义" tabindex="-1">共识的含义 <a class="header-anchor" href="#共识的含义" aria-label="Permalink to &quot;共识的含义&quot;">​</a></h1><p>对于现实世界，共识就是一群人对一件或者多件事情达成一致的看法或者协议，在计算机世界，多个节点对某个数据达成一致共识，多个节点对多个数据的顺序达成一致共识。</p><h2 id="共识算法的三大分类" tabindex="-1">共识算法的三大分类 <a class="header-anchor" href="#共识算法的三大分类" aria-label="Permalink to &quot;共识算法的三大分类&quot;">​</a></h2><ul><li><p>私链：私链的共识算法即区块链这个概念还没普及时的传统分布式系统里的共识算法，私链的适用环境一般是不考虑集群中存在作恶节点，只考虑因为系统或者网络原因导致的故障节点，常见算法包括<code>raft,paxos</code></p></li><li><p>联盟链：联盟链的适用环境除了需要考虑集群中存在故障节点，还需要考虑集群中存在作恶节点，对于联盟链，每个新加入的节点都是需要验证和审核的，常见算法包括<code>pbft,dbft</code></p></li><li><p>公链：公链不断需要考虑网络中存在故障节点，还需要考虑作恶节点，这一点和联盟链是类似的，和联盟链最大的区别就是，公链中的节点可以很自由的加入或者退出，不需要严格的验证和审核，常见算法包括<code>pow,pos,dpos,ripple</code></p></li></ul><h2 id="pow-proof-of-work" tabindex="-1"><code>Pow(Proof of Work)</code> <a class="header-anchor" href="#pow-proof-of-work" aria-label="Permalink to &quot;`Pow(Proof of Work)`&quot;">​</a></h2><h4 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h4><ul><li><p>用一份证明来确认做过一定量的工作，工作方需要花费很长时间去得出一个结果，验证方可以很容易使用该结果来验证工作方的工作量</p></li><li><p>通过暴力破解方法解决一个数学难题，在哈希计算后得到一个小于目标值的哈希值</p></li></ul><h4 id="举例" tabindex="-1">举例 <a class="header-anchor" href="#举例" aria-label="Permalink to &quot;举例&quot;">​</a></h4><p>给定一个字符串<code>Hello, world!</code>，现在要求在该字符串后面加上一个<code>nonce</code>的整数值，采用<code>SHA256</code>哈希运算之后，哈希结果符合前4位是0，即结果是<code>0000*</code>，则验证通过</p><p>可以采用<code>python</code>代码实现如下</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> hashlib</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">msg </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello, world!&quot;</span></span>\n<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">range</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1000_000_000</span><span style="color:#E1E4E8;">):</span></span>\n<span class="line"><span style="color:#E1E4E8;">    result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> hashlib.sha256(</span><span style="color:#F97583;">f</span><span style="color:#9ECBFF;">&#39;</span><span style="color:#79B8FF;">{</span><span style="color:#E1E4E8;">msg</span><span style="color:#79B8FF;">}{</span><span style="color:#E1E4E8;">i</span><span style="color:#79B8FF;">}</span><span style="color:#9ECBFF;">&#39;</span><span style="color:#E1E4E8;">.encode()).hexdigest()</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> result.startswith(</span><span style="color:#9ECBFF;">&#39;0000&#39;</span><span style="color:#E1E4E8;">):</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">f</span><span style="color:#9ECBFF;">&#39;nonce: </span><span style="color:#79B8FF;">{</span><span style="color:#E1E4E8;">i</span><span style="color:#79B8FF;">}</span><span style="color:#9ECBFF;">, result: </span><span style="color:#79B8FF;">{</span><span style="color:#E1E4E8;">result</span><span style="color:#79B8FF;">}</span><span style="color:#9ECBFF;">&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> hashlib</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292E;">msg </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello, world!&quot;</span></span>\n<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">range</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1000_000_000</span><span style="color:#24292E;">):</span></span>\n<span class="line"><span style="color:#24292E;">    result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> hashlib.sha256(</span><span style="color:#D73A49;">f</span><span style="color:#032F62;">&#39;</span><span style="color:#005CC5;">{</span><span style="color:#24292E;">msg</span><span style="color:#005CC5;">}{</span><span style="color:#24292E;">i</span><span style="color:#005CC5;">}</span><span style="color:#032F62;">&#39;</span><span style="color:#24292E;">.encode()).hexdigest()</span></span>\n<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> result.startswith(</span><span style="color:#032F62;">&#39;0000&#39;</span><span style="color:#24292E;">):</span></span>\n<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">f</span><span style="color:#032F62;">&#39;nonce: </span><span style="color:#005CC5;">{</span><span style="color:#24292E;">i</span><span style="color:#005CC5;">}</span><span style="color:#032F62;">, result: </span><span style="color:#005CC5;">{</span><span style="color:#24292E;">result</span><span style="color:#005CC5;">}</span><span style="color:#032F62;">&#39;</span><span style="color:#24292E;">)</span></span>\n<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span></span></code></pre></div><p>上面的输出结果是</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">nonce: 4250, result: 0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">nonce: 4250, result: 0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9</span></span></code></pre></div><p>上面为了计算出一个符合条件的哈希值，运算了4251次，得到了<code>nonce</code>的值为4250，这样验证方就可以拿着一个<code>Hello, world!</code>的信息，加上一个<code>nonce</code>为4250的值，运算一次，得出的哈希结果就可以验证符合要求，证明了工作量</p><h4 id="哈希函数主要说明与特征" tabindex="-1">哈希函数主要说明与特征 <a class="header-anchor" href="#哈希函数主要说明与特征" aria-label="Permalink to &quot;哈希函数主要说明与特征&quot;">​</a></h4><ul><li>输入<code>x</code>的长度任意，输出<code>H(x)</code>的长度固定，计算<code>H(x)</code>的过程是高效的</li><li>免碰撞，哈希函数的输出需要足够随机，即不会出现输入<code>x≠y</code>，但是<code>H(x)=H(y)</code>。比特币采用的<code>SHA256</code>算法，输出长度是256，输出可能性就是2^256，所以当输入2^256+1次，则必然产生一次碰撞，但是现实中，运算2^32大概是40亿次，运算2^256次是压根就没法计算完的。</li><li>不可逆性，即根据一个输出<code>H(x)</code>，不能倒推回输入<code>x</code></li></ul><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p><code>PoW</code>是比特币的共识机制，在目前的公链共识算法里面占据主导地位，矿工以计算机计算工作，获取相应的比特币奖励或者手续费，将一些列的交易打包形成块，矿工采用<code>SHA-256</code>算法，计算其块的hash值进行验证，</p><h4 id="安全性分析" tabindex="-1">安全性分析 <a class="header-anchor" href="#安全性分析" aria-label="Permalink to &quot;安全性分析&quot;">​</a></h4><p>一个破坏者拥有比特币全网算力的51%，即可以改写区块链进行欺骗，但是新区块的产生同时也会有新币奖励以及交易费的收取，这在一定程度上保护了比特币网络的安全，即攻击者会在使用高昂的算力进行欺骗以及使用算力生产新区块获取新币以及交易费之间做出选择。（但是也不排除现实中会存在一种人，就是不在乎利益的，就像功夫里面的火云邪神一样，只是想找个对手，最经典的就是对着杨过与小龙女所说的经典台词，我只是想...）</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>造假成本比较高</li></ul><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>资源浪费，挖矿需要大量的哈希运算，消耗大量资源，找到的哈希值的唯一意义就是满足了挖矿成功的定义，即该哈希的有多少个连续的0作为开头，除了使恶意攻击者不能轻易地伪装成几百万个节点和打垮比特币网络，并没有更多实际或科学价值</li><li>网络性能低，因为<code>PoW</code>共识算法限制比特币出块的时间是10分钟，所以交易确认至少需要10分钟，而且目前仅支持每秒7笔的交易速度，不适合高并发的商业应用</li><li><code>PoW</code>共识算法算力集中化，目前挖矿矿池是主力，个人矿工基本不可能生存下去，算力高的矿池有选择权，进而导致算力的集中化</li><li>随着比特币产量的不断降低， 矿工人数也会越来越少， 这样就会导致整个比特币网络的稳定性出现问题，矿工数量变少的时候，比特币被51%算力攻击就越容易</li></ul><h4 id="算法矛盾点" tabindex="-1">算法矛盾点 <a class="header-anchor" href="#算法矛盾点" aria-label="Permalink to &quot;算法矛盾点&quot;">​</a></h4><p>区块大小与出块间隔。增加区块容量可以提高吞吐量，但是区块过大会造成网络拥塞，增加节点间共识的时间和效率，反而可能降低区块效率；减小出块间隔也能增加吞吐量，但出块间隔的缩短会造成更频繁的链分叉，也会增加双花等安全问题</p><h2 id="pos-proof-of-stake" tabindex="-1"><code>Pos(Proof of Stake)</code> <a class="header-anchor" href="#pos-proof-of-stake" aria-label="Permalink to &quot;`Pos(Proof of Stake)`&quot;">​</a></h2><h4 id="概述-1" tabindex="-1">概述 <a class="header-anchor" href="#概述-1" aria-label="Permalink to &quot;概述&quot;">​</a></h4><p>基于随机选择的验证者来生产并批准区块，验证者通过在区块链内锁定代币来“质押”原生网络代币，验证者根据自己的权益质押总额获得奖励，此举可以用投资回报 (<code>ROI</code>) 来激励节点验证网络，类似现实生活中的股东机制，拥有股份越多的人越容易获取记账权，同时越倾向于维护网络的正常工作，是更加环保和更加可扩展的共识算法</p><h4 id="区块生产过程" tabindex="-1">区块生产过程 <a class="header-anchor" href="#区块生产过程" aria-label="Permalink to &quot;区块生产过程&quot;">​</a></h4><ul><li>被选出的验证者根据自己的权益质押情况产出下一个区块</li><li>权益质押数额较大的验证者生成下个区块的机会更大</li><li>区块先由部分验证者提交，然后向其他验证者播送，由这些验证者核实后将获得批准的区块添加到区块链</li></ul><h4 id="实现逻辑" tabindex="-1">实现逻辑 <a class="header-anchor" href="#实现逻辑" aria-label="Permalink to &quot;实现逻辑&quot;">​</a></h4><ul><li><p>通过保证金（ 代币、资产、名声等具备价值属性的物品） 来对赌一个合法的块成为新的区块，收益为抵押资本的利息和交易服务费</p></li><li><p>提供证明的保证金，例如通过转账货币记录越多，则获得记账权的概率就越大</p></li><li><p>恶意参与者的恶意操作并生成虚假区块，为了生成区块而按照锁定机制所质押的权益就会面临着遭到削减或被剥夺控制权的威胁（保证金被罚没，即损失经济利益），对于 <code>PoS</code> 来说，需要掌握超过全网 1/3 的资源，才有可能左右最终的结果</p></li><li><p>在<code>POS</code>模式下， 有一个概念叫币龄， 每个币每天产生1币龄， 例如，你持有 100 个币， 总共持有了 30 天， 那么， 此时你的币龄就为 3000， 这个时候， 如果你发现了一个<code>PoS</code>区块， 你的币龄就会被清空为 0。 你每被清空 365币龄， 你将会从区块中获得0.05个币的利息（ 可以理解为年利率5%） ， 那么在这个案例中， 利息<code>=3000×5%/365=0.41</code>个币</p></li></ul><h4 id="加密货币所有者获得的好处" tabindex="-1">加密货币所有者获得的好处 <a class="header-anchor" href="#加密货币所有者获得的好处" aria-label="Permalink to &quot;加密货币所有者获得的好处&quot;">​</a></h4><ul><li>持有奖励：用户只需让加密货币在自己的钱包里放上一段时间，即可赚取奖励</li><li>参与/委托奖励： 用户将自己的部分权益委托给负责保护网络的验证者。 验证者与委托权益给自己的用户分享部分权益质押收入，由此产生奖励</li></ul><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>省资源：不需要挖矿，不需要大量耗费电力和能源</li><li>更加去中心化：相对于比特币等<code>PoW</code>类型的加密货币，更加去中心化，相比<code>PoW</code>算法的51%算力攻击，<code>PoS</code>需要购买51%的货币，成本更高，没有攻击意义</li><li>避免通货膨胀：<code>PoS</code>机制的加密货币按一定的年利率新增货币，可以有效避免紧缩出现，保持基本稳定</li></ul><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li><code>POS</code>会面临发币的问题，起初只有创世块上有币，意味着只有这个节点可以挖矿，所以让币分散出去才能让网络壮大，所以早期采取的是<code>POW+POS</code>，即第一阶段<code>POW</code>挖矿，第二阶段<code>POS</code>挖矿，后来<code>ERC20</code>合约代币出现后，可以只存在<code>POS</code>的挖矿形式</li><li>开发者作恶，纯<code>PoS</code>机制的加密货币，只能通过<code>IPO</code>的方式发行，这就导致“少数人”（通常是开发者）获得大量成本极低的加密货币，很有可能造成大面积的抛售</li><li>币龄其实就是时间，一旦挖矿者囤积一定的币，很久很久之后发起攻击，这样将很容易拿到记账权</li><li>矿工可以囤积代币从而导致货币流通困难</li><li><code>POS</code>面临的最严重的一个问题就是无成本利益问题，在PoS系统中做任何事几乎没有成本，比如在<code>PoS</code>系统上挖矿几乎没有成本，这也就意味着分叉非常方便</li><li>首富账户的权力过大，可能支配记账权</li></ul><h2 id="dpos-delegated-proof-of-stake" tabindex="-1"><code>Dpos(Delegated Proof of Stake)</code> <a class="header-anchor" href="#dpos-delegated-proof-of-stake" aria-label="Permalink to &quot;`Dpos(Delegated Proof of Stake)`&quot;">​</a></h2><h4 id="概述-2" tabindex="-1">概述 <a class="header-anchor" href="#概述-2" aria-label="Permalink to &quot;概述&quot;">​</a></h4><p><code>DPO</code>S是一种基于投票选举的共识算法，有点像民主大会，持币人选出几个代表节点来运营网络，用专业运行的网络服务器来保证区块链网络的安全和性能，<code>DPOS</code>机制中，不需要算力解决数学难题，而是由持币者选出谁说生产者，如果生产者不称职，就有随时有可能被投票出局，这也就解决了<code>POS</code>的性能问题</p><h4 id="受托人-代理人-delegates-的主要职责" tabindex="-1">受托人，代理人(Delegates)的主要职责 <a class="header-anchor" href="#受托人-代理人-delegates-的主要职责" aria-label="Permalink to &quot;受托人，代理人(Delegates)的主要职责&quot;">​</a></h4><ul><li>保证节点的正常运行</li><li>收集网络里的交易</li><li>节点验证交易，把交易打包到区块</li><li>节点广播区块，其他节点验证后把区块添加到自己的数据库</li><li>带领并促进区块链项目的发展</li></ul><h4 id="实现逻辑-1" tabindex="-1">实现逻辑 <a class="header-anchor" href="#实现逻辑-1" aria-label="Permalink to &quot;实现逻辑&quot;">​</a></h4><ul><li>受托人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费</li><li>一个区块链项目的受托人个数由项目发起方决定</li><li>任何一个持币用户都可以参与到投票和竞选受托人这两个过程中，用户可以随时投票、撤票，每个用户投票的权重和自己的持币量成正比</li><li>投票和撤票可以随时进行，在每一轮选举结束后，得票率最高的<code>n</code>(区块链项目方决定)个用户则成为该项目的受托人，负责打包区块、维持系统的运转并获得相应的奖励</li><li>每名代表都有一份相等的投票权，并且，如果当前记账节点不记账则由下一个记账人记账</li></ul><h4 id="dpos机制的原则" tabindex="-1"><code>DPOS</code>机制的原则 <a class="header-anchor" href="#dpos机制的原则" aria-label="Permalink to &quot;`DPOS`机制的原则&quot;">​</a></h4><ul><li>持股人依据所持股份行使表决权，而不是依赖挖矿竞争记账权</li><li>最大化持股人的盈利</li><li>最小化维护网络安全的费用</li><li>最大化网络的效能</li><li>最小化运行网络的成本</li></ul><h2 id="pbft-practical-byzantine-fault-tolerance" tabindex="-1"><code>PBFT(Practical Byzantine Fault Tolerance)</code> <a class="header-anchor" href="#pbft-practical-byzantine-fault-tolerance" aria-label="Permalink to &quot;`PBFT(Practical Byzantine Fault Tolerance)`&quot;">​</a></h2><h4 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h4><p>拜占庭罗马帝国国土辽阔，为了达到防御目的，每块封地都驻扎一支由将军统领的军队，每个军队都分隔很远，将军与将军之间只能靠信差传递消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定影响将军们达成一致共识。在已知有将军是叛徒的情况下，其余忠诚的将军如何达成一致协议的问题，这就是拜占庭将军问题。</p><h4 id="必要前提" tabindex="-1">必要前提 <a class="header-anchor" href="#必要前提" aria-label="Permalink to &quot;必要前提&quot;">​</a></h4><p>信道必须是可靠的，如果信道不能保证可靠，在一个不可靠的通信链路上试图通过通信以达成一致是基本不可能或者十分困难的</p><h4 id="算法基本解释" tabindex="-1">算法基本解释 <a class="header-anchor" href="#算法基本解释" aria-label="Permalink to &quot;算法基本解释&quot;">​</a></h4><p>将军总数大于 <code>3f </code>，背叛者为<code>f </code>或者更少时，忠诚的将军可以达成命令上的一致，即 <code>3f+1&lt;=n</code>，即网络中全部节点总数是大于<code>3f</code>,恶意节点以及故障节点总数是小于等于<code>f</code>,那么整个集群还是可以达成一个正确的共识，该算法最大容错节点数量是<code>(n -1)/3</code>，算法需要支持容错故障节点，也需要支持容错作恶节点</p><h4 id="最好极端情况" tabindex="-1">最好极端情况 <a class="header-anchor" href="#最好极端情况" aria-label="Permalink to &quot;最好极端情况&quot;">​</a></h4><p>如果<code>f</code>个节点是故障节点，也是作恶节点，那么根据少数服从多数的原则，集群里面存在<code>f+1</code>个正常节点，那么集群就能够达成共识，这种情况支持的最大容错节点数量是<code> (n-1)/2</code></p><h4 id="最坏极端情况" tabindex="-1">最坏极端情况 <a class="header-anchor" href="#最坏极端情况" aria-label="Permalink to &quot;最坏极端情况&quot;">​</a></h4><p>故障节点和作恶节点全是不同节点，有<code>f</code>个作恶节点，有<code>f</code>个故障节点，当发现节点是作恶节点之后，集群排除节点，剩下<code>f</code>个故障节点，根据少数服从多数原则，需要<code>f+1</code>个正常节点大于<code>f</code>个故障节点，集群就能达到共识，所以最大容错节点是<code>(n-1)/3</code></p><h4 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>通信复杂度<code>O(n^2)</code>，解决了原始拜占庭容错(<code>BFT</code>)算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行</li><li>首次提出在<strong>异步网络环境下使用状态机副本复制协议</strong>，该算法可以工作在异步环境中，并且通过优化在早期算法的基础上把响应性能提升了一个数量级以上。作者使用这个算法实现了拜占庭容错的网络文件系<code>NFS</code>，性能测试证明了该系统仅比无副本复制的标准NFS慢了3%</li><li>使用了加密技术来防止欺骗攻击和重播攻击，以及检测被破坏的消息。消息包含了公钥签名（<code>RSA</code>算法）、消息验证编码<code>MAC</code>和无碰撞哈希函数生成的消息摘要</li></ul><h4 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>仅仅适用于联盟链/私有链</li><li>通信复杂度过高，可拓展性比较低，一般的系统在达到100左右的节点个数时，性能下降非常快</li><li>在网络不稳定的情况下延迟很高</li></ul><h2 id="raft" tabindex="-1"><code>Raft</code> <a class="header-anchor" href="#raft" aria-label="Permalink to &quot;`Raft`&quot;">​</a></h2><h4 id="概述-3" tabindex="-1">概述 <a class="header-anchor" href="#概述-3" aria-label="Permalink to &quot;概述&quot;">​</a></h4><p>将一致性问题看成系统中进程间在不同机器上一个状态机同步问题，为保证每个机器上的进程具有一致性，<code>Raft</code>共识算法来保证在每个进程初始状态相同的情况下，每个进程的下一个操作，状态改变操作相同，这样就能保证所有进程的状态机的改变过程是一样的，即系统中的进程最终会达成数据一致状态</p><h4 id="raft集群节点状态" tabindex="-1"><code>raft</code>集群节点状态 <a class="header-anchor" href="#raft集群节点状态" aria-label="Permalink to &quot;`raft`集群节点状态&quot;">​</a></h4><ul><li><code>leader</code>领导者，负责整个集群状态的同步和对外部事件的处理，整个集群只有一个<code>leader</code></li><li><code>follower</code>跟随者，是被动的，不会主动发出消息，只是响应<code>leader</code>或<code>candidate</code>的消息，或者转发客户端的请求给<code>leader</code></li><li><code>candidate</code>候选者，是一种临时的状态</li></ul><h4 id="领导人选举" tabindex="-1">领导人选举 <a class="header-anchor" href="#领导人选举" aria-label="Permalink to &quot;领导人选举&quot;">​</a></h4><ul><li>每个节点在加入集群的时候都会初始化为<code>follower</code></li><li>当前集群没有<code>leader</code>的时候，<code>follower</code>会进行选举试图成为<code>leader</code>，将自己的状态转变为<code>candidate</code></li><li>向集群内的其他成员发起投票请求，若该<code>candidate</code>收到了大多数人的赞成票</li><li>变成<code>leader</code>之后，集群内广播心跳消息，接到心跳消息的<code>follower</code>或其他<code>candidate</code>就会认识到此时已有<code>leader</code>，会停止自己的竞选行为而重新变为<code>follower</code>，稳定的集群状态就形成了</li></ul><h4 id="发起竞选条件" tabindex="-1">发起竞选条件 <a class="header-anchor" href="#发起竞选条件" aria-label="Permalink to &quot;发起竞选条件&quot;">​</a></h4><p>每个节点内部都有一个被称之为选举时停的属性，当在此时间段内，没有收到来自<code>leader</code>的心跳消息，就可以认为当前没有<code>leader</code>存在，可以发起竞选</p><h4 id="任期term概念" tabindex="-1">任期<code>term</code>概念 <a class="header-anchor" href="#任期term概念" aria-label="Permalink to &quot;任期`term`概念&quot;">​</a></h4><ul><li>任期<code>Term</code>是一个全局可见递增的数字</li><li>几乎每个在集群间传播的消息都会携带者发送者所属的<code>Term</code></li><li>表示一个<code>Leader</code>发挥其影响力的一段时期的序号</li><li><code>Term</code>的增加发生在一个<code>follower</code>成为<code>candidate</code>时，一个<code>follower</code>长时间未收到<code>leader</code>的心跳，它就认为新的时代要到来了，因此它自增此<code>Term</code>，成为候选者发起竞选，同时将此更新后的<code>Term</code>发送给其他节点以彰显自己的竞选资格</li></ul><h4 id="日志序号index概念" tabindex="-1">日志序号Index概念 <a class="header-anchor" href="#日志序号index概念" aria-label="Permalink to &quot;日志序号Index概念&quot;">​</a></h4><ul><li>纪录了节点日志<code>entry</code>的序号</li></ul><h4 id="follower投票给candidate的条件" tabindex="-1"><code>follower</code>投票给<code>candidate</code>的条件 <a class="header-anchor" href="#follower投票给candidate的条件" aria-label="Permalink to &quot;`follower`投票给`candidate`的条件&quot;">​</a></h4><ul><li>投票的原则是先来先投票</li><li>在一个<code>Term</code>内只能投一次赞成票，如若下一个来请求投票的<code>candidate</code>的<code>Term</code>更大（表示可能进入到了下一轮的选举），那么投票者会重置自己的<code>Term</code>为最新然后重新投票</li><li><code>candidate</code>的日志<code>index</code>大于自己的日志<code>index</code></li><li><code>candidate</code>的<code>term</code>大于自身的<code>term</code></li></ul><h4 id="选举失败后续流程" tabindex="-1">选举失败后续流程 <a class="header-anchor" href="#选举失败后续流程" aria-label="Permalink to &quot;选举失败后续流程&quot;">​</a></h4><p><code>candidate</code>的选举活动有一个最大时限，超过该时限还没有成功胜出，就会被宣布为失败，重新变为<code>follower</code>然后重新开始选举时停的计时，为了保证选票瓜分的情况不会频繁出现，每一个节点的选举时停都是随机的</p><h4 id="日志复制阶段" tabindex="-1">日志复制阶段 <a class="header-anchor" href="#日志复制阶段" aria-label="Permalink to &quot;日志复制阶段&quot;">​</a></h4><ul><li>提案阶段：是一个初始阶段，当<code>leader</code>收到来自客户端的一条请求后，会将请求打包成为一个<code>entry</code>，该<code>entry</code>便处于此阶段，它是不稳定的，也就是说集群没有办法保证此<code>entry</code>会被集群接受还是抛弃（网络、机器原因），需要<code>raft</code>共识算法发挥其作用来确定</li><li>达成共识阶段/可提交阶段：一旦某一<code>entry</code>被集群内大多数节点所持有，该<code>entry</code>就已经处于达成共识阶段，它已经能够确定将会被集群接受（提交），但具体何时写入状态机，外部客户端何时能够验证此命令已经生效，则是没有办法保证的</li><li>被提交阶段：可认为是显式的达成共识阶段。当<code>leader</code>意识到某一个<code>entry</code>已经进入了达成共识阶段，则<code>leader</code>将会将它标记为被提交状态。并将此信息广播给集群中的其他节点声明该<code>entry</code>已经被集群接受，可以将其应用进状态机了</li><li>被应用状态：当集群中的任意节点意识到某一个<code>entry</code>已经被标记为已提交，而且自身也持有这个<code>entry</code>，就会将其应用进状态机，对于<code>KV</code>数据库可能是写、删除操作等，此时一个请求才真正被完成，可以被外部验证其已被执行</li></ul><h2 id="参考阅读" tabindex="-1">参考阅读 <a class="header-anchor" href="#参考阅读" aria-label="Permalink to &quot;参考阅读&quot;">​</a></h2><p><a href="https://www.yuanyuzhouneican.com/article-157274.html" target="_blank" rel="noreferrer">区块链<code>pow</code>算法介绍</a></p><p><a href="https://zhuanlan.zhihu.com/p/353293420" target="_blank" rel="noreferrer">死磕共识算法|<code>POS</code>算法</a></p><p><a href="https://zhuanlan.zhihu.com/p/34107097" target="_blank" rel="noreferrer">详解<code>DPoS</code>共识算法</a></p><p><a href="https://www.jianshu.com/p/b23cbafbbad2" target="_blank" rel="noreferrer">区块链共识算法-<code>POW</code>-简书</a></p><p><a href="https://zhuanlan.zhihu.com/p/35847127" target="_blank" rel="noreferrer">共识算法系列之一：<code>raft</code>和<code>pbft</code>算法</a></p><p><a href="https://www.cnblogs.com/zmk-c/p/14535734.html" target="_blank" rel="noreferrer"><code>PBFT</code>共识算法详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/404315977" target="_blank" rel="noreferrer">分布式共识算法Raft（可用性和一致性）详解</a></p>',90),d=[s];function n(r,t,i,p,h,u){return a(),o("div",null,d)}const b=e(c,[["render",n]]);export{y as __pageData,b as default};
